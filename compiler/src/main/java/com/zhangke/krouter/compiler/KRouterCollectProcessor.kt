package com.zhangke.krouter.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSNode
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import com.zhangke.krouter.annotation.Destination
import com.zhangke.krouter.compiler.ext.asClassDeclaration
import com.zhangke.krouter.compiler.ext.findArgumentTypeByName
import com.zhangke.krouter.compiler.ext.isSingleElement
import com.zhangke.krouter.compiler.ext.requireAnnotation
import com.zhangke.krouter.compiler.ext.typeQualifiedName
import kotlin.math.absoluteValue
import kotlin.random.Random

/**
 * 最终生成示例
 *
 * ```kotlin
 * package com.zhangke.krouter.generated
 *
 * import com.zhangke.krouter.test.MainScreen
 * import com.zhangke.krouter.test.SettingsScreen
 * import com.zhangke.krouter.test.TestScreen
 *
 * /**
 *  * This class is generated by KRouter, do not modify it.
 * */
 * private class `KRouterMap$$1986967826` {
 *   private lateinit var com_zhangke_krouter_test_TestScreen: TestScreen
 *   private lateinit var com_zhangke_krouter_test_MainScreen: MainScreen
 *   private lateinit var com_zhangke_krouter_test_SettingsScreen: SettingsScreen
 * }
 * ```
 *
 * 专门用于收集路由信息的处理器
 */
open class KRouterCollectProcessor(
    protected val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    protected fun log(message: String, symbol: KSNode? = null) =
        environment.logger.warn(message, symbol)

    companion object {
        const val GENERATED_SHARED_PACKAGE = "com.zhangke.krouter.generated"
        const val CLASS_KDOC = "This class is generated by KRouter, do not modify it."
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val destinations = resolver.getSymbolsWithAnnotation(Destination::class.qualifiedName!!)
            .map { it as KSClassDeclaration }
            .toList()

        writeToFile(environment.codeGenerator, destinations)

        return emptyList()
    }

    private fun writeToFile(
        codeGenerator: CodeGenerator,
        collectedMap: List<KSClassDeclaration>
    ) {
        if (collectedMap.isEmpty()) return

        val propertySpecs = collectedMap.mapNotNull { item ->
            val name = item.qualifiedName?.asString()
                ?.replace('.', '_')
                ?.takeIf(String::isNotBlank)
                ?: return@mapNotNull null

            PropertySpec.builder(name, item.toClassName())
                .addModifiers(KModifier.LATEINIT, KModifier.PRIVATE)
                .mutable(true)
                .build()
        }

        val className = "KRouterMap\$\$${Random.nextInt().absoluteValue}"
        val classSpec = TypeSpec.classBuilder(className)
            .apply { modifiers += KModifier.PRIVATE }
            .addKdoc(CLASS_KDOC)
            .addProperties(propertySpecs)
            .build()

        val fileSpec = FileSpec.builder(GENERATED_SHARED_PACKAGE, className)
            .addType(classSpec)
            .indent("    ")
            .build()

        // 将涉及到的类所涉及的文件作为依赖传入，方便增量编译
        val dependencies = collectedMap
            .mapNotNull { it.containingFile }
            .distinct()
            .toTypedArray()

        fileSpec.writeTo(
            codeGenerator = codeGenerator,
            dependencies = Dependencies(aggregating = false, *dependencies)
        )
    }
}