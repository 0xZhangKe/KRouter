package com.zhangke.krouter.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSNode
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import com.zhangke.krouter.annotation.Destination
import kotlin.math.absoluteValue
import kotlin.random.Random

/**
 * 专门用于收集路由信息的处理器
 */
open class KRouterCollectProcessor(
    protected val environment: SymbolProcessorEnvironment
) : SymbolProcessor {
    protected fun log(message: String, symbol: KSNode? = null) =
        environment.logger.warn(message, symbol)

    companion object {
        private val badTypeName = Unit::class.qualifiedName
        private val badSuperTypeName = Any::class.qualifiedName
        const val GENERATED_SHARED_PACKAGE = "com.zhangke.krouter.generated"
        const val CLASS_KDOC = "This class is generated by KRouter, do not modify it."
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val destinations = resolver.getSymbolsWithAnnotation(Destination::class.qualifiedName!!)
            .map { it as KSClassDeclaration }
            .toList()

        val collectedMap = destinations.map { collect(it) }
            .groupBy({ it.first }, { it.second })

        writeToFile(environment.codeGenerator, collectedMap)

        return emptyList()
    }

    private fun collect(targetClass: KSClassDeclaration): Pair<KSClassDeclaration, KSClassDeclaration> {
        val routerAnnotation = targetClass.requireAnnotation<Destination>()

        // 首先看注解是否有自定义的目标父类
        val targetSuperClass = routerAnnotation.findArgumentTypeByName("type")
            ?.asClassDeclaration()

        // 若获取到自定义的目标父类，则检查该类是否被目标类继承
        if (targetSuperClass != null && targetSuperClass.qualifiedName?.asString() != badTypeName) {
            checkSuperClassExist(targetClass, targetSuperClass)

            return targetSuperClass to targetClass
        }

        // 若没有自定义的目标父类，则判断目标类是否有且只有一个父类，若有则使用该父类作为目标父类
        val superType = targetClass.superTypes
            .takeIf { it.isSingleElement() }
            ?.firstOrNull { typeRef ->
                typeRef.typeQualifiedName
                    ?.takeIf(String::isNotBlank)
                    ?.let { it != badSuperTypeName }
                    ?: false
            }?.resolve()?.declaration as? KSClassDeclaration

        if (superType == null) {
            throw IllegalArgumentException("${targetClass.qualifiedName} must have a super class")
        }

        return superType to targetClass
    }

    private fun checkSuperClassExist(
        targetClass: KSClassDeclaration,
        targetSuperClass: KSClassDeclaration
    ) {
        val targetSuperClassName = targetSuperClass.qualifiedName?.asString()

        if (targetSuperClassName == badTypeName || targetSuperClassName == badSuperTypeName) {
            throw IllegalArgumentException("[checkSuperClassExist]: $targetSuperClassName is not valid")
        }

        if (!targetClass.superTypes.iterator().asSequence()
                .any { it.typeQualifiedName == targetSuperClassName }
        ) {
            throw IllegalArgumentException("${targetClass.qualifiedName} must inherit from $targetSuperClassName")
        }
    }

    private fun writeToFile(
        codeGenerator: CodeGenerator,
        collectedMap: Map<KSClassDeclaration, List<KSClassDeclaration>>
    ) {
        if (collectedMap.isEmpty()) return

        val propertySpecs = collectedMap.mapNotNull { entry ->
            val key = entry.key.qualifiedName?.asString()
                ?.replace('.', '_')
                ?.takeIf(String::isNotBlank)
                ?: return@mapNotNull null

            entry.value.mapNotNull mapNotNull1@{
                val name = it.qualifiedName?.asString()
                    ?.replace('.', '_')
                    ?.takeIf(String::isNotBlank)
                    ?: return@mapNotNull1 null

                PropertySpec.builder("$key#$name", it.toClassName())
                    .addModifiers(KModifier.LATEINIT, KModifier.PRIVATE)
                    .mutable(true)
                    .build()
            }
        }.flatten()

        val className = "KRouterMap\$\$${Random.nextInt().absoluteValue}"
        val classSpec = TypeSpec.classBuilder(className)
            .apply { modifiers += KModifier.PRIVATE }
            .addKdoc(CLASS_KDOC)
            .addProperties(propertySpecs)
            .build()

        val fileSpec = FileSpec.builder(GENERATED_SHARED_PACKAGE, className)
            .addType(classSpec)
            .indent("    ")
            .build()

        // 将涉及到的类所涉及的文件作为依赖传入，方便增量编译
        val dependencies = (collectedMap.keys + collectedMap.values.flatten())
            .mapNotNull { it.containingFile }
            .distinct()
            .toTypedArray()

        fileSpec.writeTo(
            codeGenerator = codeGenerator,
            dependencies = Dependencies(aggregating = false, *dependencies)
        )
    }
}