package com.zhangke.krouter.compiler

import com.google.devtools.ksp.KspExperimental
import com.google.devtools.ksp.getDeclaredProperties
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.STAR
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.writeTo
import com.zhangke.krouter.compiler.ext.asClassDeclaration
import kotlin.reflect.KClass

/**
 * 最终生成示例
 *
 * ```kotlin
 * package com.zhangke.krouter.generated
 *
 * import com.zhangke.krouter.KRouterRegister
 * import com.zhangke.krouter.test.MainScreen
 * import com.zhangke.krouter.test.SettingsScreen
 * import com.zhangke.krouter.test.TestScreen
 * import kotlin.reflect.KClass
 *
 * /**
 *  * This class is generated by KRouter, do not modify it.
 *  */
 * private class KRouterInjectMap : KRouterRegister {
 *     override fun inject(): Map<String, List<KClass<*>>> = mapOf(
 *         "com.zhangke.krouter.test.Screen" to listOf(TestScreen::class, MainScreen::class),
 *         "com.zhangke.krouter.test.TabScreen" to listOf(SettingsScreen::class)
 *     )
 * }
 * ```
 *
 * 真正实现路由注入的处理器，继承自KRouterCollectProcessor
 * 收集完所在模块后才会执行注入操作
 */
class KRouterInjectProcessor(
    environment: SymbolProcessorEnvironment
) : KRouterCollectProcessor(environment) {

    @OptIn(KspExperimental::class)
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val resultList = super.process(resolver)

        // 若存在生成的文件，则说明收集到了路由信息，还会触发一次process，此时可跳过注入操作
        if (environment.codeGenerator.generatedFile.isNotEmpty()) {
            return resultList
        }

        val generatedItems = resolver.getDeclarationsFromPackage(GENERATED_SHARED_PACKAGE)
        val propertiesItems = generatedItems.map {
            it.asClassDeclaration().getDeclaredProperties()
        }.flatten()

        val collectedMap = propertiesItems.map { property ->
            val propertyName = property.simpleName.asString()
                .substringBefore("#")
                .replace('_', '.')

            val propertyClazz = property.type
                .resolve()
                .declaration
                .asClassDeclaration()

            propertyName to propertyClazz
        }.groupBy({ it.first }, { it.second })

        writeToFile(environment.codeGenerator, collectedMap)

        return resultList
    }

    private fun writeToFile(
        codeGenerator: CodeGenerator,
        collectedMap: Map<String, List<KSClassDeclaration>>
    ) {
        if (collectedMap.isEmpty()) return

        val mapItems = collectedMap.map { entry ->
            val classNames = entry.value.map { it.toClassName() }.toTypedArray()
            val template = classNames.joinToString(",") { "%T::class" }
            CodeBlock.builder()
                .addStatement("%S to listOf($template)", entry.key, *classNames)
                .build()
        }.toTypedArray()

        val template = mapItems.joinToString(",") { "%L" }
        val codeBlock = CodeBlock.builder()
            .addStatement("return mapOf($template)", *mapItems)
            .build()

        val funcSpec = FunSpec.builder("get")
            .addModifiers(KModifier.OVERRIDE)
            .addCode(codeBlock)
            .returns(
                // Map<String, List<KClass<*>>>
                Map::class.asClassName().parameterizedBy(
                    String::class.asTypeName(),
                    List::class.asClassName().parameterizedBy(
                        KClass::class.asClassName().parameterizedBy(STAR)
                    )
                )
            )
            .build()

        val className = "KRouterInjectMap"
        val classSpec = TypeSpec.classBuilder(className)
            .addModifiers(KModifier.PRIVATE)
            .addSuperinterfaces(listOf(ClassName.bestGuess("com.zhangke.krouter.KRouterRegister")))
            .addKdoc(CLASS_KDOC)
            .addFunction(funcSpec)
            .build()

        val fileSpec = FileSpec.builder(GENERATED_SHARED_PACKAGE, className)
            .addType(classSpec)
            .indent("    ")
            .build()

        // 将涉及到的类所涉及的文件作为依赖传入，方便增量编译
        val dependencies = collectedMap.values.flatten()
            .mapNotNull { it.containingFile }
            .distinct()
            .toTypedArray()

        kotlin.runCatching {
            fileSpec.writeTo(
                codeGenerator = codeGenerator,
                dependencies = Dependencies(aggregating = false, *dependencies)
            )
        }
    }
}